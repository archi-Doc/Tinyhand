using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Tinyhand;
using Tinyhand.IO;
using Tinyhand.Resolvers;

// <auto-generated/>
#nullable enable
#pragma warning disable CS1591

namespace Benchmark.H2HTest
{
    public partial class ObjectH2H : ITinyhandSerialize, ITinyhandReconstruct
    {
        public void Serialize(ref TinyhandWriter writer, TinyhandSerializerOptions options)
        {
            writer.WriteArrayHeader(9);
            writer.Write(this.X);
            writer.Write(this.Y);
            writer.Write(this.Z);
            writer.Write(this.A);
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            writer.WriteNil();
            global::Tinyhand.Formatters.Builtin.SerializeInt32Array(ref writer, this.B);
        }
        public void Deserialize(ref TinyhandReader reader, TinyhandSerializerOptions options)
        {
            var numberOfData = reader.ReadArrayHeader();
            options.Security.DepthStep(ref reader);
            try
            {
                if (numberOfData-- > 0 && !reader.TryReadNil())
                {
                    this.X = reader.ReadInt32();
                }
                else
                {
                    this.X = 0;
                }
                if (numberOfData-- > 0 && !reader.TryReadNil())
                {
                    this.Y = reader.ReadInt32();
                }
                else
                {
                    this.Y = 0;
                }
                if (numberOfData-- > 0 && !reader.TryReadNil())
                {
                    this.Z = reader.ReadInt32();
                }
                else
                {
                    this.Z = 0;
                }
                if (numberOfData-- > 0 && !reader.TryReadNil())
                {
                    this.A = reader.ReadString();
                }
                else
                {
                    this.A = string.Empty;
                }
                if (numberOfData-- > 0) reader.Skip();
                if (numberOfData-- > 0) reader.Skip();
                if (numberOfData-- > 0) reader.Skip();
                if (numberOfData-- > 0) reader.Skip();
                if (numberOfData-- > 0 && !reader.TryReadNil())
                {
                    this.B = global::Tinyhand.Formatters.Builtin.DeserializeInt32Array(ref reader) ?? new int[0];
                }
                else
                {
                    this.B = new int[0];
                }
                while (numberOfData-- > 0) reader.Skip();
            }
            finally { reader.Depth--; }
        }
        public void Reconstruct(TinyhandSerializerOptions options)
        {
            if (this.A == null) 
            {
                this.A = string.Empty;
            }
            if (this.B == null) 
            {
                this.B = new int[0];
            }
        }
    }

    public partial class ObjectH2H2 : ITinyhandSerialize, ITinyhandReconstruct
    {
        public void Serialize(ref TinyhandWriter writer, TinyhandSerializerOptions options)
        {
            writer.WriteMapHeader(5);
            writer.WriteString(ObjectH2H2.__gen_utf8_key_0000);
            writer.Write(this.X);
            writer.WriteString(ObjectH2H2.__gen_utf8_key_0001);
            writer.Write(this.Y);
            writer.WriteString(ObjectH2H2.__gen_utf8_key_0002);
            writer.Write(this.Z);
            writer.WriteString(ObjectH2H2.__gen_utf8_key_0003);
            writer.Write(this.A);
            writer.WriteString(ObjectH2H2.__gen_utf8_key_0004);
            global::Tinyhand.Formatters.Builtin.SerializeInt32Array(ref writer, this.B);
        }
        public void Deserialize(ref TinyhandReader reader, TinyhandSerializerOptions options)
        {
            ulong key;
            var deserializedFlag = new bool[5];
            var numberOfData = reader.ReadMapHeader();
            options.Security.DepthStep(ref reader);
            try
            {
                while (numberOfData-- > 0)
                {
                    var utf8 = reader.ReadStringSpan();
                    if (utf8.Length == 0)
                    {
                        goto SkipLabel;
                    }
                    key = global::Tinyhand.Generator.AutomataKey.GetKey(ref utf8);
                    if (key < 0x58)
                    {
                        if (utf8.Length != 0) goto SkipLabel;
                        if (key == 0x41)
                        {
                            deserializedFlag[3] = true;
                            if (!reader.TryReadNil())
                            {
                                this.A = reader.ReadString();
                            }
                            else
                            {
                                this.A = string.Empty;
                            }
                        }
                        else if (key == 0x42)
                        {
                            deserializedFlag[4] = true;
                            if (!reader.TryReadNil())
                            {
                                this.B = global::Tinyhand.Formatters.Builtin.DeserializeInt32Array(ref reader) ?? new int[0];
                            }
                            else
                            {
                                this.B = new int[0];
                            }
                        }
                    }
                    else
                    {
                        if (utf8.Length != 0) goto SkipLabel;
                        if (key == 0x58)
                        {
                            deserializedFlag[0] = true;
                            if (!reader.TryReadNil())
                            {
                                this.X = reader.ReadInt32();
                            }
                            else
                            {
                                this.X = 0;
                            }
                        }
                        else if (key == 0x59)
                        {
                            deserializedFlag[1] = true;
                            if (!reader.TryReadNil())
                            {
                                this.Y = reader.ReadInt32();
                            }
                            else
                            {
                                this.Y = 0;
                            }
                        }
                        else if (key == 0x5A)
                        {
                            deserializedFlag[2] = true;
                            if (!reader.TryReadNil())
                            {
                                this.Z = reader.ReadInt32();
                            }
                            else
                            {
                                this.Z = 0;
                            }
                        }
                    }
                    continue;
SkipLabel:
                    reader.Skip();
                }

                if (!deserializedFlag[3] && this.A == null)
                {
                    this.A = string.Empty;
                }
                if (!deserializedFlag[4] && this.B == null)
                {
                    this.B = new int[0];
                }
            }
            finally { reader.Depth--; }
        }
        public void Reconstruct(TinyhandSerializerOptions options)
        {
            if (this.A == null) 
            {
                this.A = string.Empty;
            }
            if (this.B == null) 
            {
                this.B = new int[0];
            }
        }

        private static ReadOnlySpan<byte> __gen_utf8_key_0000 => new byte[] { 88, };
        private static ReadOnlySpan<byte> __gen_utf8_key_0001 => new byte[] { 89, };
        private static ReadOnlySpan<byte> __gen_utf8_key_0002 => new byte[] { 90, };
        private static ReadOnlySpan<byte> __gen_utf8_key_0003 => new byte[] { 65, };
        private static ReadOnlySpan<byte> __gen_utf8_key_0004 => new byte[] { 66, };
    }
}
