// Copyright (c) All contributors. All rights reserved. Licensed under the MIT license.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Arc.Visceral;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

#pragma warning disable SA1401 // Fields should be private

namespace Tinyhand.Generator;

internal class TinyhandGenerateMemberBody : VisceralBody<TinyhandGenerateMemberObject>
{
    public TinyhandGenerateMemberBody(SourceProductionContext context)
        : base(context)
    {
    }

    internal Dictionary<string, List<TinyhandGenerateMemberObject>> Namespaces = new();

    public void Generate(IGeneratorInformation generator, CancellationToken cancellationToken)
    {
        if (this.Namespaces.Count == 0)
        {
            return;
        }

        ScopingStringBuilder ssb = new();
        GeneratorInformation info = new();

        // Namespace - Objects
        foreach (var x in this.Namespaces)
        {
            cancellationToken.ThrowIfCancellationRequested();
            this.GenerateHeader(ssb);
            ssb.AppendNamespace(x.Key);

            var firstFlag = true;
            foreach (var y in x.Value)
            {
                if (!firstFlag)
                {
                    ssb.AppendLine();
                }

                firstFlag = false;
                y.Generate(ssb, info);
            }

            var result = ssb.Finalize();

            if (generator.GenerateToFile && generator.TargetFolder != null && Directory.Exists(generator.TargetFolder))
            {
                this.StringToFile(result, Path.Combine(generator.TargetFolder, $"gen.GenerateMember.{x.Key}.cs"));
            }
            else
            {
                var hintName = $"gen.GenerateMember.{x.Key}";
                var sourceText = SourceText.From(result, Encoding.UTF8);
                this.Context?.AddSource(hintName, sourceText);
                this.Context2?.AddSource(hintName, sourceText);
            }
        }
    }

    public void Prepare()
    {
        // Configure objects.
        var array = this.FullNameToObject.ToArray();
        foreach (var x in array)
        {
            x.Value.Configure();
        }

        this.FlushDiagnostic();
        if (this.Abort)
        {
            return;
        }

        array = this.FullNameToObject.Where(x =>
        x.Value.ObjectFlag.HasFlag(TinyhandGenerateMemberObjectFlag.TinyhandGenerateMember) ||
        x.Value.ObjectFlag.HasFlag(TinyhandGenerateMemberObjectFlag.TinyhandGenerateHash)).ToArray();
        foreach (var x in array)
        {
            x.Value.ConfigureRelation();
        }

        // Check
        foreach (var x in array)
        {
            x.Value.Check();
        }

        this.FlushDiagnostic();
        if (this.Abort)
        {
            return;
        }
    }

    private void GenerateHeader(ScopingStringBuilder ssb)
    {
        ssb.AddHeader("// <auto-generated/>");
        ssb.AddUsing("System");
        // ssb.AddUsing("Tinyhand");
        ssb.AppendLine("#pragma warning disable CS1591", false);
        ssb.AppendLine();
    }
}
