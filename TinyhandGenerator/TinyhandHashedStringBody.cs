// Copyright (c) All contributors. All rights reserved. Licensed under the MIT license.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Arc.Visceral;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

#pragma warning disable RS2008
#pragma warning disable SA1306 // Field names should begin with lower-case letter
#pragma warning disable SA1310 // Field names should not contain underscore
#pragma warning disable SA1401 // Fields should be private
#pragma warning disable SA1117 // Parameters should be on same line or separate lines

namespace Tinyhand.Generator;

internal class TinyhandHashedStringBody : VisceralBody<TinyhandHashedStringObject>
{
    public TinyhandHashedStringBody(SourceProductionContext context)
        : base(context)
    {
    }

    internal Dictionary<string, List<TinyhandHashedStringObject>> Namespaces = new();

    public void Generate(IGeneratorInformation generator, CancellationToken cancellationToken)
    {
        if (this.Namespaces.Count == 0)
        {
            return;
        }

        ScopingStringBuilder ssb = new();
        GeneratorInformation info = new();

        // Namespace - Objects
        foreach (var x in this.Namespaces)
        {
            cancellationToken.ThrowIfCancellationRequested();
            this.GenerateHeader(ssb);
            var ns = ssb.ScopeNamespace(x.Key);

            var firstFlag = true;
            foreach (var y in x.Value)
            {
                if (!firstFlag)
                {
                    ssb.AppendLine();
                }

                firstFlag = false;
                y.Generate(ssb, info);
            }

            var result = ssb.Finalize();

            if (generator.GenerateToFile && generator.TargetFolder != null && Directory.Exists(generator.TargetFolder))
            {
                this.StringToFile(result, Path.Combine(generator.TargetFolder, $"gen.HashedString.{x.Key}.cs"));
            }
            else
            {
                var hintName = $"gen.HashedString.{x.Key}";
                var sourceText = SourceText.From(result, Encoding.UTF8);
                this.Context?.AddSource(hintName, sourceText);
                this.Context2?.AddSource(hintName, sourceText);
            }
        }
    }

    public void Prepare()
    {
        // Configure objects.
        var array = this.FullNameToObject.ToArray();
        foreach (var x in array)
        {
            x.Value.Configure();
        }

        this.FlushDiagnostic();
        if (this.Abort)
        {
            return;
        }

        array = this.FullNameToObject.Where(x => x.Value.ObjectFlag.HasFlag(TinyhandHashedStringObjectFlag.TinyhandHashedString)).ToArray();
        foreach (var x in array)
        {
            x.Value.ConfigureRelation();
        }

        // Check
        foreach (var x in array)
        {
            x.Value.Check();
        }

        this.FlushDiagnostic();
        if (this.Abort)
        {
            return;
        }
    }

    private void GenerateHeader(ScopingStringBuilder ssb)
    {
        ssb.AddHeader("// <auto-generated/>");
        ssb.AddUsing("System");
        ssb.AddUsing("Tinyhand");
        ssb.AppendLine();
    }
}
